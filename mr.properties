num_of_inputfiles=1

#\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306E\u30B5\u30A4\u30BA(MB): long
# size of one Input File_Minimum (in MB)
size_of_inputfile_min=512

# size of one Input File_Max (in MB)
size_of_inputfile_max=512

# inputsplit\u306E\u30B5\u30A4\u30BA(MB)
# size of InputSplit (in MB).
# If "is_size_dynamic" is set as "0", this value is used as
# a predefined size.
size_of_inputsplit=64

# InputSplit\u5185\u306E\u30EC\u30B3\u30FC\u30C9\u30B5\u30A4\u30BA(MB)
#\u5C0F\u6570\u70B9\u5024\u3082OK
# Record size of each InputSplit(MB).
# type: double, i.e., floating point OK.
size_of_inputrecord=2

# OutRecord/InputRecord\u306E\u30B5\u30A4\u30BA\u6BD4\u03C1
# \u305F\u3068\u3048\u3070InputReord\u30B5\u30A4\u30BA\u3092A\u3068\u3059\u308B\u3068\uFF0C
# OutputRecord\u30B5\u30A4\u30BA\u306F\u03C1A\u3067\u3042\u308A\uFF0C
# \u30AD\u30FC\u305F\u3061\u306E\u91CD\u307F\u3092\u8003\u616E\u3059\u308B\u3068
# \u5404\u30AD\u30FC\u306E\u30B5\u30A4\u30BA\u306F\u03C1A x w(k_i)/w(k_1)+w(k_2)..+w(k_n)
# Size Ratio of OutRecord Size / Input Record Size.
# The size of a output data in terms of Key_i in a output record is
# \u03C1A x w(k_i)/{w(k_1)+w(k_2)..+w(k_n)}
# Also \u03C1A is the same as the spill buffer record
# the number of spill buffer records per one spill file is
# (spill file size / \u03C1A)
split_out_in_rate=1.0

# ShuffleFIleSplit\u3092Reduce\u51FA\u529B\u3057\u305F\u30B5\u30A4\u30BA/SFS\u30D5\u30A1\u30A4\u30EB\u30B5\u30A4\u30BA\u306E\u6BD4\u7387\uFF0E
# Output Size / Input Size at a Reducer.
reduce_out_in_rate=1.0

# \u30D5\u30A1\u30A4\u30EB\u30DB\u30B9\u30C8\u306E\u51E6\u7406\u901F\u5EA6
# Proc. Speed in HDFS.
# "1000" means 1.0 GHz.
dfhost_mips=3000

# \u30D5\u30A1\u30A4\u30EB\u30DB\u30B9\u30C8\u306E\u5E2F\u57DF\u5E45(MB)
# comm. bandwidth of HDFS.
dfhost_bw=125

# 0: \u30DE\u30EB\u30C1\u30AD\u30E3\u30B9\u30C8\u3067Mapper 1: \u9010\u6B21\u7684\u306B\u30C7\u30FC\u30BF\u8EE2\u9001\u3059\u308B\uFF0E
#\u5165\u529B\u30C7\u30FC\u30BF\u3092\u8EE2\u9001\u3059\u308B\uFF0E
# HDFS -> \u8907\u6570Mapper\u3078\u306E\u8EE2\u9001\uFF0CMapper->\u8907\u6570Reducer\u3078\u306Eshuffle\u8EE2\u9001\u3067\u4F7F\u308F\u308C\u308B\uFF0E
# 0: multicast transfer mode (HDFS->mappers@initial deployment of map tasks,  and mappers -> reducers@shuffle phase)
# 1: sequential data transfer mode.
dfs_transfer_mode=1

# 0: \u3059\u3079\u3066\u56FA\u5B9A\u5024\uFF08size_of_inputsplit\u5024\u304C\u4F7F\u308F\u308C\u308B\uFF09
# 1: \u52D5\u7684\u306B\u6C7A\u307E\u308B\uFF08\u5404Mapper\u3054\u3068\u306Bsize_of_inputsplit\u30B5\u30A4\u30BA\u3092\u6C7A\u3081\u308B\uFF09
# 0: every input split size is the same.
# 1: each input split size is adjusted according to the target mapper's attributes(not implemented).
is_size_dynamic=0

# 1\u3064\u306EInputSplit\u751F\u6210\u306E\u4ED5\u4E8B\u91CF(\u5E73\u5747\u5024\uFF09@DFS
# Workload per one InputSplit generation @ HDFS.
is_gen_workload_ave=10

# 1\u3064\u306E\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u5185\u306E\u30AD\u30FC\u306E\u7A2E\u985E\u6570
# Number of key kinds
in_record_num_of_kinds_keys_min=30
in_record_num_of_kinds_keys_max=30
dist_in_record_num_of_kinds_keys=1
dist_in_record_num_of_kinds_mu=0.5

# \u51FA\u529B\u30AD\u30FC\u6570 / \u5165\u529B\u30AD\u30FC\u6570
# number of output keys / number of input keys ratio.
key_rate=1.0

# workload for sorting one key in the collect phase.
workload_partitioning_per_key=5

# 1\u3064\u306E\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u5185\u306E1\u30AD\u30FC\u306E\u91CD\u307F\u5206\u5E03\uFF08\u4F8B\uFF1A\u30AD\u30FC\u306E\u6570\uFF08\u300C\u30A2\u30E1\u30EA\u30AB\u300D\u306E\u6570\u306E\u3053\u3068\uFF09
# \u3053\u306E\u5024\u306B\u5FDC\u3058\u3066\uFF0C\u30B7\u30E3\u30C3\u30D5\u30EB\u6642\u306E\u30AD\u30FC\u5358\u4F4D\u306E\u30C7\u30FC\u30BF\u30B5\u30A4\u30BA\u304C\u9055\u3063\u3066\u304F\u308B\uFF0E
# \u51FA\u529B\u30D5\u30A1\u30A4\u30EB\u30B5\u30A4\u30BA\u3082\u9055\u3046\uFF0E
# \u5B9F\u969B\u306B\u306F\uFF0C\u30AD\u30FC\u306E\u51FA\u73FE\u56DE\u6570\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\uFF0E
# data size weight for each key.
# the larger, the larget its data size become in a input /output record.
key_weight_min=3
key_weight_max=10
dist_key_weight=1
dist_key_weight_mu=0.5

# 1\u3064\u306Einputrecord\u751F\u6210\u6642\uFF0C1MB\u3042\u305F\u308A\u51E6\u7406\u3059\u308B\u306E\u306B\u304B\u304B\u308B\u4ED5\u4E8B\u91CF\uFF08\u56FA\u5B9A\uFF09
# double\u578B
# workload for generating one input record per 1 MB.
# double type (floating point OK).
in_record_workload_perMB=1.0

# \u30D5\u30A1\u30A4\u30EB\u66F8\u304D\u51FA\u3057\u6642\uFF0C1MB\u3042\u305F\u308A\u306E\u51E6\u7406\u306E\u4ED5\u4E8B\u91CF
# Spill\u30D5\u30A1\u30A4\u30EB\u751F\u6210\uFF0CMergedFile\u751F\u6210(\u66F8\u304D\u51FA\u3057\uFF09\u6642\u306B\u4F7F\u308F\u308C\u308B\uFF0E
# double\u578B
# workload for serializing 1 MB. (double type)
out_record_workload_perMB=3.0

# spill\u30D5\u30A1\u30A4\u30EB\u306E\u8AAD\u307F\u8FBC\u307F\u6642\u306B\uFF0C1MB\u3042\u305F\u308A\u306E\u8AAD\u307F\u8FBC\u307F\u4ED5\u4E8B\u91CF
# workload for reading spill file per 1MB.
spill_read_workload_perMB=5.0

# merge\u30D5\u30A1\u30A4\u30EB\u751F\u6210\u6642\uFF0Cspill\u30D5\u30A1\u30A4\u30EB\u3069\u3046\u3057\u3092\u7D50\u5408\u3059\u308B\u306E\u306B\u304B\u304B\u308B
# \u4ED5\u4E8B\u91CF(1\u56DE\u306Espill\u30D5\u30A1\u30A4\u30EB\u540C\u58EB\u306Emerge\uFF09
merge_workload_permerge=5

# vCPU\u5168\u4F53\u306B\u304A\u3051\u308Bmapper\u6570\u306E\u5272\u5408
num_mapper_rate=0.7

# Mapper\u6570\u306B\u5BFE\u3059\u308BReducer\u6570\u306E\u5272\u5408
# \u5168\u4F53\u6570 * num_mapper_rate * num_reducer_rate_to_mapper\u304C
# \u5B9F\u969B\u306EReducer\u6570\uFF0E
num_reducer_rate_to_mapper=0.5

# \u30B9\u30EC\u30C3\u30C9\u51E6\u7406\u3092\u4F55\u500D\u901F\u3067\u884C\u3046\u304B\u306E\u5024\uFF0E
# \u5024x\u306F\uFF0Cx\u500D\u901F\u3068\u3044\u3046\u3053\u3068\uFF0E
# Nx speed.  is the value N is specified,
# the actual simulation time is (time/N)
# (However, displayed exec. time is "time").
time_speed_rate=100

# Scheduling\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u306E\u7DCF\u6570
# Number of scheduling algorithms.
mr_algorithm_scheduling_num=1

# Scheduling\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3067\uFF0C\u4F7F\u3046\u3082\u306E
# 0: Base 1:??? 2:???
mr_algorithm_scheduling_using=0

# Provisioning\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u306E\u7DCF\u6570
# Number of Provisioning algorithms.
mr_algorithm_provisioning_num=4

# Provisioning\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\u3067\uFF0C\u4F7F\u3046\u3082\u306E
# 0: Base 1:Convex 2:BaseGW 3: ConvexGW
# the used provisioning algorithm
mr_algorithm_provisioning_using=3

# Mapper\u306E\u6570\uFF0E\u3053\u306E\u6570\u305A\u3064\u4E26\u5217\u306B\u51E6\u7406\u3055\u308C\u308B\uFF0E
# \u4F7F\u308F\u308C\u3066\u3044\u306A\u3044\uFF0E
#mapper_num=30

# Reducer\u306E\u6570
# \u4F7F\u308F\u308C\u3066\u3044\u306A\u3044\uFF0E
#reducer_num=3

############## Cloud\u74B0\u5883\u306E\u8A2D\u5B9A #####################
# \u30B3\u30A2\u306E\u5229\u7528\u7387\u4E0A\u9650\u3092\u8003\u616E\u3059\u308B\u304B\u3069\u3046\u304B
# 0: \u8003\u616E\u3057\u306A\u3044 1: \u8003\u616E\u3059\u308B
cloud_constrained_mode=0

# \u30B3\u30A2\u306E\u4F7F\u7528\u7387\u306E\u4E0A\u9650\u5024
core_max_usage=100

datacenter_num=1
#BW at a DC (MBps)
datacenter_externalbw_min=125
datacenter_externalbw_max=125
host_num_foreachdc_min=100
host_num_foreachdc_max=100

# 1\u30DB\u30B9\u30C8\u5185\u306EVM\u6570
vm_num_foreachdc_min=1
vm_num_foreachdc_max=1

#0: uniform distribution 1: normal distribution
dist_host_cpu_num=1
dist_host_cpu_num_mu=0.5
host_cpu_num_min=1
host_cpu_num_max=1
host_core_num_foreachcpu_min=1
host_core_num_foreachcpu_max=1
# If "2", the core supports Hyperthreading
host_thread_num_foreeachcore=1

# Memory (MB)
vm_mem_min=1024
vm_mem_max=8192

# MIPS(1\u79D2\u3042\u305F\u308A\u306E\u547D\u4EE4\u6570\uFF08\u767E\u4E07\uFF09
# MPIS = clock frequency/CPI / 10^6
#0: uniform distribution 1: normal distribution
dist_host_mips=1
dist_host_mips_mu=0.5
host_mips_min=2000
host_mips_max=3000

# Core\u306E\u30EC\u30FC\u30C8\uFF1DCPU\u901F\u5EA6\u306B\u5BFE\u3059\u308B\u5272\u5408
core_mips_rate_min=1.0
core_mips_rate_max=1.0



#BW (MB)
#0: uniform distribution 1: normal distribution
dist_host_bw=1
dist_host_bw_mu=0.5
host_bw_min=125
host_bw_max=125
#CPI(Cycle per Instruction)
vm_cpi=1
# Num of vCPUs for each VM.
dist_vm_vcpu_num=1
dist_vm_vcpu_num_mu=0.5
vm_vcpu_num_min=2
vm_vcpu_num_max=4


######\u2193\u306F\u7121\u95A2\u4FC2\u3060\u304C\uFF0C\u8A18\u8F09\u304C\u5FC5\u8981###########

# VNF\u3092vCPU\u3078\u5272\u308A\u5F53\u3066\u305F\u3068\u304D\u306E\u5229\u7528\u7387\u4E0A\u6607\u5024\uFF08%)
vnf_usage_min=20
vnf_usage_max=80
# 0: uniform distribution, 1: normal distribution
dist_vnf_usage=1
dist_vnf_usage_mu=0.5

vnf_type_max=10



#Instructions / 10^7
# 3.0GHz\u30671\u79D2 = 300
vnf_weight_min=500
vnf_weight_max=1000
# 0: uniforma distribution 1: normal distribution
dist_vnf_weight=1
dist_vnf_weight_mu=0.5

# MB
# 100Mbps (125MB/s)\u30671\u79D2 = 125
vnf_datasize_min=10
vnf_datasize_max=100
# uniform distribution 1: normal distirbution
dist_vnf_datasize=1
dist_vnf_datasize_mu=0.5

# MB
# \u30AA\u30D5\u30ED\u30FC\u30C9\u3059\u308B\u30E2\u30B8\u30E5\u30FC\u30EB\u81EA\u4F53\u306E\u30B5\u30A4\u30BA
offload_program_datasize=2

# 0: single SFC mode, 1: multiple SFC mode
sfc_multimode=0

# Number of VNFs in a SFC.
sfc_vnf_num=200
# degree is supposed to be set as normal distribution with mu=0.5
sfc_vnf_outdegree_min=1
sfc_vnf_outdegree_max=5

sfc_vnf_startnumrate=0.05
sfc_vnf_deapthalpha=1

# case of multiple SFCs.
multiple_sfc_num=10
multiple_sfc_vnf_num_min=30
multiple_sfc_vnf_num_max=70
dist_multiple_sfc_vnf_num=1
dist_multiple_sfc_vnf_num_mu=0.5


# FOR VNFScheduling Algorithm
# 0:average 1: max 2: min
calcmode_level=0


# For Fair VNF Scheduling Algorithm
nfv_fairness_weight_overlap=0.4

# For VNF-COUHF Algorithm
# 0: one vCPU 1: vCPUs in the Host, 2: all vCPU 3: Custom
cmwsl_sched_area=3


# Num. of mobile devices.
mobile_device_num=10
mobile_device_core_num_min=2
mobile_device_core_num_max=4
# Instructions per second / 10^7
mobile_device_cpu_mips_min=10
mobile_device_cpu_mips_max=25
# mbps
mobile_device_bw_min=50
mobile_device_bw_max=100

mobile_device_power_min=0.7
mobile_device_power_max=0.9
dist_mobile_device_power=1
dist_mobile_device_power_mu=0.5

mobile_device_gain_min=0.7
mobile_device_gain_max=0.9
dist_mobile_device_gain=1
dist_mobile_device_gain_mu=0.5

mobile_device_back_noise=10
# Number of channels.
mec_channel_num=14

mobile_device_tau_min=0.7
mobile_device_tau_max=0.9
dist_mobile_device_tau=1
dist_mobile_device_tau_mu=0.5
